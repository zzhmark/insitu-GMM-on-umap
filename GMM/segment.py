import numpy as np
from typing import Tuple, List

from sklearn.mixture import GaussianMixture, BayesianGaussianMixture
import pandas as pd


def gmm(data: np.ndarray, n: int, method: str = 'default') -> \
        Tuple[List[int], List[int]]:
    """
    :param data: list of input
    :param n: number of components
    :param method: 'default' or 'bayesian'
    :return: (labels, means)
    """
    # To avoid error, the number of components should be
    # no more than the length of input data.
    noc = min(len(data), n)
    if method.lower() == 'bayesian':
        model = BayesianGaussianMixture(n_components=noc, random_state=123)
        model.fit(data)
    else:
        model = GaussianMixture(n_components=noc, random_state=123)
        model.fit(data)
    return model.predict(data), model.means_


def global_gmm(expr: np.ndarray, n: int):
    """
    :param expr: a list of values representing expression
    :param n: number of components
    :return: (labels, means table)
    Solve GMM for the heat map, iteratively find
    the minimalist mean of GMM models and separate the
    corresponding points.
    """
    # Down sample the images and masks to reduce calculation.
    label_out = np.zeros(expr.shape, dtype=np.uint8)
    min_expr = np.min(expr)
    expr_copy = expr - min_expr
    nol = 0  # The count of labels.
    model_out = pd.DataFrame(columns=[0, 1])
    global_mean = np.mean(expr_copy)
    while True:
        labels, means = gmm(expr_copy, n)
        max_pts, max_mean = labels == np.argmax(means), max(means)
        # When the minimum mean reach the global mean, break the loop.
        if max_mean < global_mean:
            break
        # Otherwise, label the points in the output mask,
        # and dump them in the next run.
        nol += 1
        label_out[max_pts] = nol
        expr_copy[max_pts] = 0
        model_out = model_out.append([[nol, max_mean + min_expr]])
    model_out.columns = ['label', 'mean']
    model_out = model_out.set_index('label')
    return label_out, model_out


def local_gmm(coord: np.ndarray, label: np.ndarray,
              global_model: pd.DataFrame, n: int) -> \
        Tuple[np.ndarray, np.ndarray, pd.DataFrame]:
    """
    :param coord: a list of coordinates
    :param global_model: parameters of global gmm, pandas data frame
    :param n: maximum number of components for the bayesian algorithm
    :return: (labels, means table)
    Solve GMM for points' local distribution within
    each grayscale level generated by the global model.
    """
    label_out = np.zeros(label.shape)
    model_out = pd.DataFrame(columns=['label', 'mean'])
    # Iterate over different expression levels in the global model.
    for i, mean in zip(global_model.index, global_model['mean']):
        pts = coord[label == i]  # Retrieve points with a specific label.
        labels = gmm(pts, n, 'bayesian')[0]
        # Adjust labels from 0..n-1 to 1..n.
        # Because labels can be discontinuous.
        levels = np.unique(labels)
        labels = [np.where(levels == i)[0][0] + 1 for i in labels]
        # Label the areas on the output mask.
        start = np.max(label_out)
        for p, label in zip(pts, labels):
            label_out[tuple(p)] = start + label
        model = pd.DataFrame({'label': [*range(start, start + max(labels))],
                              'mean': [mean] * max(labels)})
        model_out = model_out.append(model)
    model_out = model_out.set_index('label')
    return label_out, model_out
